# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'pokerRange.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets, uic
from PyQt6.QtWidgets import QMessageBox, QFileDialog

from PyQt6.QtCore import *
from PyQt6.QtGui import *

import numpy as np
import pandas as pd
import math
import re
import json

from poker import Range
from poker.hand import Hand
from utils import *

from windowClasses import ExtraWindow_label


class Ui_MainWindow(QtWidgets.QMainWindow):

    def __init__(self):
        super().__init__()
        uic.loadUi("pokerRange.ui", self)

        self.buttons_click_actions()
        self.dict_range = {}

        self.eventfilter_elements()
        self.treeWidget_range.itemClicked.connect(self.display_range_by_item)
        
        # self.treeWidget_range.itemDoubleClicked.connect(self.rename_value)
        # self.treeWidget_range.itemChanged.connect(self.checkName, Qt.ConnectionType.QueuedConnection)



    def eventfilter_elements(self):
        """
        Contains all elements which uses alternative event filter
        """

        self.lbl_cnt_combos.installEventFilter(self)
  

    
    def buttons_click_actions(self):
        """
        Contains all connections between buttons and actions
        """
        self.actionLoad.triggered.connect(lambda: self.menu_elements_action(self.actionLoad.text()))
        self.actionSave.triggered.connect(lambda: self.menu_elements_action(self.actionSave.text()))
        self.actionClose.triggered.connect(lambda: self.menu_elements_action(self.actionClose.text()))

        self.btn_allrange.clicked.connect(lambda: self.buttons_range(self.btn_allrange.text()))
        self.btn_pocket.clicked.connect(lambda: self.buttons_range(self.btn_pocket.text()))
        self.btn_broadway.clicked.connect(lambda: self.buttons_range(self.btn_broadway.text()))
        self.btn_suited.clicked.connect(lambda: self.buttons_range(self.btn_suited.text()))
        self.btn_clear.clicked.connect(self.clear_label)

        self.tEdit_range.textChanged.connect(self.tEditTextChangeEvent)

        self.checkBox_hoverMode.stateChanged.connect(self.Hover_method)

        for button in self.gridLayoutWidget.findChildren(QtWidgets.QAbstractButton):
            button.clicked.connect(lambda: self.rangeButtonClicked())

        self.btn_addRange.clicked.connect(lambda: self.treeWidget_buttons(self.btn_addRange.text()))
        self.btn_Delete.clicked.connect(lambda: self.treeWidget_buttons(self.btn_Delete.text()))
        self.btn_addCategory.clicked.connect(lambda: self.treeWidget_buttons(self.btn_addCategory.text()))
        self.btn_Rename.clicked.connect(lambda: self.treeWidget_buttons(self.btn_Rename.text()))

    def eventFilter(self, obj, event):
        """
        Contains custom events
        """
        if event.type() == QEvent.Type.HoverEnter:
            sender = obj
            if type(sender) == QtWidgets.QPushButton:
                sender.nextCheckState()
                self.rangeButtonClicked(sender)

        if event.type() == QEvent.Type.MouseButtonDblClick and obj is self.lbl_cnt_combos:
            ui = ExtraWindow_label(self)
            ui.show()

        elif event.type() == QEvent.Type.HoverMove:
            pass
        elif event.type() == QEvent.Type.HoverLeave:
            pass
        return super().eventFilter(obj, event)

    def Hover_method(self):
        """
        Activate hover mode for range buttons
        """
        sender = self.sender()
        if sender.isChecked():
            for button in self.gridLayoutWidget.findChildren(QtWidgets.QAbstractButton):
                button.setAttribute(Qt.WidgetAttribute.WA_Hover)
                button.installEventFilter(self)
        else:
            for button in self.gridLayoutWidget.findChildren(QtWidgets.QAbstractButton):
                button.removeEventFilter(self)

    def rangeButtonClicked(self, obj = None):
        """
        Change check status for button and update textEdit, label with combos 
        """
        if obj:
            sender = obj
        else:
            sender = self.sender()

        if sender.isChecked():
            new_range = self.tEdit_range.toPlainText() + ' ' + sender.text()
            self.tEdit_range.setPlainText(str(Range(new_range)))
        
        else:
            current_range = [str(i) for i in Range(self.tEdit_range.toPlainText()).hands]
            new_range = [i for i in current_range if i != sender.text()]
            self.tEdit_range.setPlainText(str(Range(' '.join(new_range))))

        current_range = Range(self.tEdit_range.toPlainText())
        
        self.update_combo_label(current_range)


    def update_combo_label(self, combos_range):
        """
        Update current number of combos in a Qlabel

        :combos_range: poker Range format of current combos
        """
        sender = self.lbl_cnt_combos

        combos_pattern = '\d* combos'
        percent_pattern = '\d*\.{,1}\d* %'
        
        combos_text = re.findall(combos_pattern, sender.text())[0]
        percent_text = re.findall(percent_pattern, sender.text())[0]

        new_combos_cnt = 0

        combos = [str(i) for i in combos_range.hands]
        for hand in combos:
            if hand[-1] == 's':
                new_combos_cnt += 4
            elif hand[-1] == 'o':
                new_combos_cnt += 12
            else:
                new_combos_cnt += 6
        
        new_text = sender.text().replace(combos_text, str(new_combos_cnt) + ' combos').replace(percent_text, str(round(len(combos)/ len(list(Hand))* 100, 1)) + ' %')
        sender.setText(new_text)    

    def buttons_range(self, button_text):
        """
        Draw range depending on the button
        """
        all_hands = [str(hand) for hand in Range('XX').hands]
        if button_text == 'All':
            hands_remained = all_hands
    
        if button_text == 'Broadway':
            hands_remained = [hand for hand in all_hands if (hand[0] in ['A', 'K', 'Q', 'J', 'T']) and (hand[1] in ['A', 'K', 'Q', 'J', 'T'])]

        if button_text == 'Pocket':
            hands_remained = [hand for hand in all_hands if len(hand) == 2]
 
        if button_text == 'Suited':
            hands_remained = [hand for hand in all_hands if hand[-1] == 's']

        range_updated = self.tEdit_range.toPlainText() + ' ' + str(Range(' '.join(hands_remained)))

        self.tEdit_range.setPlainText(str(Range(range_updated)))

        for button in self.gridLayoutWidget.findChildren(QtWidgets.QAbstractButton):
            if button.text() in hands_remained:
                button.setChecked(True)

        current_range = Range(self.tEdit_range.toPlainText())
        self.update_combo_label(current_range) 

    def tEditTextChangeEvent(self):
        """
        Update all widgets when you change tEdit Plain Text
        """
        text = self.tEdit_range.toPlainText()
        try:
            r_text = Range(text)
            r_text_str = [str(h) for h in r_text.hands]

            for button in self.gridLayoutWidget.findChildren(QtWidgets.QAbstractButton):
                if button.text() in r_text_str:
                    button.setChecked(True)
                else:
                    button.setChecked(False)

            self.update_combo_label(r_text)
        except Exception:
            pass

    def menu_elements_action(self, menu_btn):
        """
        Actions for every item in the menu
        """
        twidget = self.treeWidget_range

        if menu_btn == 'Load':

            fname = QFileDialog.getOpenFileName(self, "Open Excel File", "", self.tr("Excel files (*.xlsx *.xls *.xml)"))[0]
            try:
                df = pd.read_excel(fname, header=None)
                try:
                    Range(df.iloc[0, 2])
                except ValueError:
                    df = pd.read_excel(fname)

                for i in range(len(df.columns)):
                    df.iloc[:, i] = df.iloc[:, i].astype('str')
                
                current_top_lvl_items = [twidget.topLevelItem(i).text(0) for i in range(twidget.topLevelItemCount())]

                for group in df.iloc[:,0].unique():
                    tmp_df = df[df.iloc[:,0] == group]
                    if group not in current_top_lvl_items:
                        top_item = QtWidgets.QTreeWidgetItem([group])
                        tmp_dict = {}
                        for cat in tmp_df.iloc[:, 1].values:
                            child_item = QtWidgets.QTreeWidgetItem([cat])
                            top_item.addChild(child_item)
                            tmp_dict[cat] = Range(tmp_df[tmp_df.iloc[:,1] == cat].iloc[:,2].values[0])
                        
                        self.dict_range[group] = tmp_dict
                        twidget.addTopLevelItem(top_item)
                    else:
                        top_item = twidget.topLevelItem(current_top_lvl_items.index(group))
                        current_child_lvl_items = [top_item.child(i).text(0) for i in range(top_item.childCount())]

                        tmp_dict = {k: v for k,v in self.dict_range[group].items()}

                        for cat in tmp_df.iloc[:, 1].values:
                            if cat not in current_child_lvl_items:
                                child_item = QtWidgets.QTreeWidgetItem([cat])
                                tmp_dict[cat] = Range(tmp_df[tmp_df.iloc[:,1] == cat].iloc[:,2].values[0])

                            else:
                                new_name = cat + '_' + str(len(current_child_lvl_items))
                                child_item = QtWidgets.QTreeWidgetItem([new_name])
                                tmp_dict[new_name] = Range(tmp_df[tmp_df.iloc[:,1] == cat].iloc[:,2].values[0])

                            top_item.addChild(child_item)

                        self.dict_range[group] = tmp_dict   

                self.statusBar().showMessage('Range loaded')    
            except FileNotFoundError:
                pass
        
        if menu_btn == 'Save':
            
            try:
                if twidget.topLevelItemCount() == 0:
                    if self.tEdit_range.toPlainText() == '':
                        customMessageBox('Warning message', 'Please, select range', 'Warning')
                        return
                    else:
                        df = pd.DataFrame({'group': ['0'],
                                           'category_name': ['current_range'],
                                           'range': [self.tEdit_range.toPlainText()]})

                else:
                    df_form = []
                    for i in range(twidget.topLevelItemCount()):
                        top_item = twidget.topLevelItem(i)
                        top_item_name = top_item.text(0)
                        for j in range(top_item.childCount()):
                            child = top_item.child(j)
                            child_name = child.text(0)
                            df_form.append((top_item_name, child_name, ', '.join(self.dict_range[top_item_name][child_name].rep_pieces)))
                        
                    df = pd.DataFrame(df_form, columns=['group', 'category_name', 'range'])
                
                fname = QFileDialog.getSaveFileName(self, "Save Excel File", "", self.tr("Excel files (*.xlsx *.xls *.xml)"))[0]

                try:
                    df.to_excel(fname, index=False)
                    self.statusBar().showMessage('Range saved') 
                except Exception:
                    pass


            except Exception:
                pass

        if menu_btn == 'Close':
            sys.exit()

    def display_range_by_item(self):
        """
        Connection between QListWidget item and buttons. Display choosen range 
        """
        widget = self.treeWidget_range
        

        try:
            item = widget.currentItem()
            item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEditable)

            parent = item.parent()

            if parent:
                range_list = [str(i) for i in self.dict_range[parent.text(0)][item.text(0)].hands]

                for button in self.gridLayoutWidget.findChildren(QtWidgets.QAbstractButton):
                        if button.text() in range_list:
                            button.setChecked(True)
                        else:
                            button.setChecked(False)
                
                range_str = ', '.join(self.dict_range[parent.text(0)][item.text(0)].rep_pieces)
                self.tEdit_range.setPlainText(range_str)


            
        except AttributeError:
            print('1')
            pass
    
    def clear_label(self):
        """
        Change check status of pushed buttons and clear textEdit
        """

        for button in self.gridLayoutWidget.findChildren(QtWidgets.QAbstractButton):
            if button.isChecked():
                button.nextCheckState()

        self.tEdit_range.setPlainText('')
        self.tEdit_name.setPlainText('')

        cnt_combos = self.lbl_cnt_combos.text().split()[0]
        self.lbl_cnt_combos.setText(self.lbl_cnt_combos.text().replace(cnt_combos, '0'))
       
    def get_list_of_pushed_buttons(self):
        """
        Function create list of buttons which Check state is True

        return: list, Range  
        """
        list_of_pushed_button = []

        for button in self.gridLayoutWidget.findChildren(QtWidgets.QAbstractButton):
            if button.isChecked():
                list_of_pushed_button.append(button.text())
        range_view_of_pushed_buttons = Range(' '.join(list_of_pushed_button))
        return sorted(list_of_pushed_button), range_view_of_pushed_buttons


    def treeWidget_buttons(self, btn_name):
        """
        Contains all buttons actions with QTreeWidget
        """
        
        widget = self.treeWidget_range

        if btn_name == 'Add Range':
            try:
                item = widget.currentItem()
                parent = item.parent()
                if not parent:
                    current_child_lvl_items = [item.child(i).text(0) for i in range(item.childCount())]


                    category_name = self.tEdit_name.toPlainText()

                    if category_name == '':
                        name = str(item.childCount())
                    else:
                        name = category_name
                    if name not in current_child_lvl_items:
                        childWidget = QtWidgets.QTreeWidgetItem(item)
                        childWidget.setText(0, name)
                        item.addChild(childWidget)

                    _, cur_range = self.get_list_of_pushed_buttons()
                    self.dict_range[item.text(0)][name] = cur_range                    

            except Exception:
                customMessageBox('Warning message', 'Please, select category', 'Warning')


        elif btn_name == 'Add Category':
            current_top_lvl_items = [widget.topLevelItem(i).text(0) for i in range(widget.topLevelItemCount())]

            category_name = self.tEdit_name.toPlainText()
            if category_name == '':
                name = str(widget.topLevelItemCount())
            else:
                name = category_name

            if name not in current_top_lvl_items:
                widget.addTopLevelItem(QtWidgets.QTreeWidgetItem([name]))
                self.dict_range[name] = {}

        elif btn_name == 'Rename':
            item = widget.currentItem()
            parent = item.parent()
            
            category_name = self.tEdit_name.toPlainText()

            if parent:
                current_items = [parent.child(i).text(0) for i in range(parent.childCount())]
            else:
                current_items = [widget.topLevelItem(i).text(0) for i in range(widget.topLevelItemCount())]

            if category_name == '':
                name = '_'
            else:
                name = category_name

            if (name not in current_items) and (not parent):
                self.dict_range[name] =  self.dict_range.pop(item.text(0))
                item.setText(0, name)


            elif (name not in current_items) and (parent):
                self.dict_range[parent.text(0)][name] =  self.dict_range[parent.text(0)].pop(item.text(0))
                item.setText(0, name)            

        elif btn_name == 'Delete':
            try:
                item = widget.currentItem()
                parent = item.parent()

                if parent:
                   parent.takeChild(parent.indexOfChild(item))
                   self.dict_range[parent.text(0)].pop(item.text(0))
                else:
                    index = widget.indexOfTopLevelItem(item)
                    widget.takeTopLevelItem(index)
                    self.dict_range.pop(item.text(0))
            except Exception:
                pass


    # Попытки сделать treeWidgetItem is Editable с последующей постпроверкой ... Но что-то работает херово 
    # def rename_value(self):
    #     item = self.treeWidget_range.currentItem()
    #     item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
        
    # def checkName(self, item, column):

    #     item_text = item.data(0,0)
    #     siblings = self.getSiblings(item)

    #     if item_text in siblings:
    #         print('Duplicate item')
    #         item.setData(0,0, 'Plese enter a new value')

    #         self.treeWidget_range.editItem(item)

    # def getSiblings(self, item):
    #     siblings = [self.treeWidget_range.topLevelItem(i).data(0,0) for i in range(self.treeWidget_range.topLevelItemCount())]
    #     item_text = item.data(0,0)

    #     if item_text in siblings:
    #         siblings.remove(item_text)
        
    #     return siblings


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    ui = Ui_MainWindow()
    ui.show()
    sys.exit(app.exec())